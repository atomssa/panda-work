//#include "hphysicsconstants.h"
#include "HBeam.h"
//#include "hhistmap.h"

#include "TRandom.h"
#include "TH1F.h"
#include "TH1F.h"
#include "TH2F.h"
#include "TMath.h"
#include "TVector3.h"
#include "TLorentzVector.h"
#include "TCanvas.h"
#include "TString.h"
#include "TF1.h"
#include "TFile.h"
#include "TTree.h"

#include <iostream>
#include <stdio.h>
#include <vector>
#include <map>
#include <assert.h>

using namespace std;


int main( int argc, const char **argv )
{


  //int nEvents=100000;
  int nEvents=10000;  
  TString outfile="test_pion_0.01_0.05_0.6.evt";
    
  map<Int_t,TString> elementNames;

  elementNames[0]  = "in_Q1";
  elementNames[1]  = "out_Q1";
  elementNames[2]  = "in_Q2";
  elementNames[3]  = "out_Q2";
  elementNames[4]  = "out_Q2_+_0.6_m";
  elementNames[5]  = "in_FOPI";
  elementNames[6]  = "in_FOPI";
  elementNames[7]  = "out_FOPI";
  elementNames[8]  = "out_FOPI";
  elementNames[9]  = "in_dip_1";
  elementNames[10] = "out_dip_1";
  elementNames[11] = "in_Q3";
  elementNames[12] = "out_Q3";
  elementNames[13] = "in_Q4";
  elementNames[14] = "out_Q4";
  elementNames[15] = "inter_focal_plane";
  elementNames[16] = "detector_I";
  elementNames[17] = "in_Q5"; // Position of Det1
  elementNames[18] = "out_Q5";
  elementNames[19] = "in_Q6";
  elementNames[20] = "out_Q6";
  elementNames[21] = "in_dip_2";
  elementNames[22] = "out_dip_2";
  elementNames[23] = "in_Q7";
  elementNames[24] = "out_Q7";
  elementNames[25] = "inter_point_det_2";
  elementNames[26] = "in_Q8";
  elementNames[27] = "out_Q8";
  elementNames[28] = "in_Q9";
  elementNames[29] = "out_Q9";
  elementNames[30] = "inter_point";
  elementNames[31] = "HADES_target";
  elementNames[32] = "target";


  Int_t cuttup[] = {      // 0 = no, 1=radial, 2=box
    1,1,1,1,2, //5
    2,2,2,2,2, //10
    2,1,1,1,1, //15
    1,2,1,1,1, //20
    1,2,2,1,1, //25
    2,1,1,1,1, //30
    1,1,1
  };

  Double_t xcut[] =  {   // [mm]

    60.,60.,60.,60.,70.,   //5
    70.,70.,70.,70.,90.,   //10
    90.,60.,60.,60.,60.,   //15
    60.,50.,60.,60.,60.,   //20
    60.,90.,90.,60.,60.,   //25
    50.,60.,60.,60.,60.,   //30
    60.,60.,6
  };

  Double_t ycut[] =        // [mm]
    {
      60.,60.,60.,60.,35., //5
      35.,35.,35.,35.,35., //10
      35.,60.,60.,60.,60., //15
      60.,50.,60.,60.,60., //20
      60.,35.,35.,60.,60., //25
      50.,60.,60.,60.,60., //30
      60.,60.,6
    };

  HBeam pionbeam;
  //pionbeam.setBeam           (HPhysicsConstants::pid("pi-"),1.3,60,60,0.0,0.0); // id, totl mom [GeV], beamtube x and y size, xoff,yoff
  // http://web-docs.gsi.de/~halo/docs/hydra/classDocumentation/dev/src/HPhysicsConstants.cxx.html#f0lQqE
  pionbeam.setBeam           (9,1.3,60,60,0.0,0.0); // id, totl mom [GeV], beamtube x and y size, xoff,yoff    
  //pionbeam.setBeamProfile    (.5,0.0);                // sigma [mm], flatradius [mm]
  pionbeam.setBeamProfile    (0.0,0.0);                // sigma [mm], flatradius [mm]  
  //pionbeam.setBeamResolution (0.01,0.05,0.06);          // dpx [rad],dpy [rad] ,dpz [relative]  [+-]
  pionbeam.setBeamResolution (0.00,0.0,0.06);          // dpx [rad],dpy [rad] ,dpz [relative]  [+-]  
  if(!pionbeam.initBeamLine  ("pibeam_set6_mod.data",32)) return 1;               // transform input file and target element number
  //pionbeam.addDetector("det1", 0.03, 9.36, -17092.6,2,50.,50.);                             // thicknes[cm], rad len[cm], [mm] relative to HADES 0,0,0
  pionbeam.addDetector("det1", 0.0, 9.36, -17092.6,2,50.,50.);                             // thicknes[cm], rad len[cm], [mm] relative to HADES 0,0,0  
  pionbeam.addDetector("det2", 0.03, 9.36, -5400.0,2,50.,50.);                              // thicknes[cm], rad len[cm], [mm] relative to HADES 0,0,0
  //pionbeam.addDetector("det2", 0.0, 9.36, -5400.0,2,50.,50.);                              // thicknes[cm], rad len[cm], [mm] relative to HADES 0,0,0  
  pionbeam.addDetector("plane", 0.0, -1300.0,1,60.,60.);                              // thicknes[cm], rad len[cm], [mm] relative to HADES 0,0,0
  //pionbeam.addDetector("diamond", 0.03, 18.8, -400.0,2,7.1,7.1);                              // thicknes[cm], rad len[cm], [mm] relative to HADES 0,0,0  (Start detector)
  pionbeam.addDetector("diamond", 0.0, 18.8, -400.0,2,7.1,7.1);                              // thicknes[cm], rad len[cm], [mm] relative to HADES 0,0,0  (Start detector)  

  vector<HBeamElement>& elements  = pionbeam.getElements();
  //vector<HBeamElement>& detectors = pionbeam.getDetectors();

  if(elementNames.size() != elements.size()) {
    cout<<"Number of elements differs from name map! nelements = "<<elements.size()<<", map size = "<<elementNames.size()<<endl;
    return 1;
  }

  for(UInt_t i = 0 ; i < elements.size(); i++){
    elements[i].setElement(elementNames[i],cuttup[i],xcut[i],ycut[i]);
  }

  pionbeam.printBeamLine(kFALSE);   // kTRUE : print transform matrices in addition to name and distance, kFALSE : don't
  pionbeam.printDetectors();
  pionbeam.printBeamProfile();

  Bool_t bWriteDetectors = kFALSE; // true : write det1,det2 as beam particles

  TString histfile = outfile;
  histfile.ReplaceAll(".evt","");
  histfile.ReplaceAll(".root","");
  histfile += "_histmap.root";
  TFile *fout = TFile::Open(histfile,"RECREATE");
  fout->mkdir("xy");
  fout->mkdir("xth");
  fout->mkdir("yph");  
  fout->mkdir("mom");
  fout->mkdir("mom_x");    
  fout->mkdir("mom_y");
  fout->mkdir("mom_z");
  fout->mkdir("acceptance");
  fout->mkdir("dir");    

  vector<HBeamParticle>& vhistory = pionbeam.newParticle();
  static const unsigned int ndet = vhistory.size();
  
  TTree *tt = new TTree("t","t");
  int _ndet=ndet;       tt->Branch("ndet",&_ndet,"ndet/I");
  float _acc=0;      tt->Branch("acc",&_acc,"acc/F");
  float _p[ndet];    tt->Branch("p[ndet]",&_p,"p[ndet]/F");
  float _x[ndet];    tt->Branch("x[ndet]",&_x,"x[ndet]/F");
  float _y[ndet];    tt->Branch("y[ndet]",&_y,"y[ndet]/F");
  float _th[ndet];   tt->Branch("th[ndet]",&_th,"th[ndet]/F");
  float _ph[ndet];   tt->Branch("ph[ndet]",&_ph,"ph[ndet]/F");  

  // msi == multiple scattering initial state
  int _nmspt = 4; tt->Branch("nmspt",&_nmspt,"nmspt/I");
  float _msi_x[_nmspt]; tt->Branch("msi_x[nmspt]",&_msi_x,"msi_x[nmspt]/F");
  float _msi_th[_nmspt]; tt->Branch("msi_th[nmspt]",&_msi_th,"msi_th[nmspt]/F");
  float _msi_y[_nmspt]; tt->Branch("msi_y[nmspt]",&_msi_y,"msi_y[nmspt]/F");
  float _msi_ph[_nmspt]; tt->Branch("msi_ph[nmspt]",&_msi_ph,"msi_ph[nmspt]/F");
  float _msi_dp[_nmspt]; tt->Branch("msi_dp[nmspt]",&_msi_dp,"msi_dp[nmspt]/F");
  
  TH2F* h_xy[ndet], *h_xyAcc[ndet];
  TH2F* h_xth[ndet], *h_xthAcc[ndet];
  TH2F* h_yph[ndet], *h_yphAcc[ndet];    
  TH1F* h_mom[ndet], *h_momAcc[ndet];
  TH1F* h_mom_x[ndet], *h_momAcc_x[ndet];
  TH1F* h_mom_y[ndet], *h_momAcc_y[ndet];
  TH1F* h_mom_z[ndet], *h_momAcc_z[ndet];

  int indexOut = 0;
  int indexDet[2] = {0};
  double r_pos = 100.0;
  double r_ang = 20;  
  
  for (UInt_t idet=0; idet< ndet; ++idet) {
    const char *det_name = vhistory[idet].fName.Data();
    if (strcmp(det_name, "plane")) indexOut = idet;
    if (strcmp(det_name, "det1")) indexDet[0] = idet;
    if (strcmp(det_name, "det2")) indexDet[1] = idet;

    h_xy[idet] = new TH2F( Form("hxy_%s",det_name), Form("x vs. y [%s]; x[mm]; y[mm]; counts",det_name), 2000, -r_pos, r_pos, 2000, -r_pos, r_pos );
    h_xyAcc[idet] = new TH2F( Form("hxyAcc_%s",det_name), Form("x vs. y, accepted [%s]; x[mm]; y[mm]",det_name), 2000, -r_pos, r_pos, 2000, -r_pos, r_pos );

    h_xth[idet] = new TH2F( Form("hxth_%s",det_name), Form("#theta vs. x [%s]; x[mm]; #theta[mrad]; counts",det_name), 2000, -r_pos, r_pos, 2000, -r_ang, r_ang );
    h_xthAcc[idet] = new TH2F( Form("hxthAcc_%s",det_name), Form("#theta vs. x, accepted [%s]; x[mm]; #theta[mrad]; counts",det_name), 2000, -r_pos, r_pos, 2000, -r_ang, r_ang );
    
    h_yph[idet] = new TH2F( Form("hyph_%s",det_name), Form("#phi vs. x [%s]; y[mm]; #phi[mrad]; counts",det_name), 2000, -r_pos, r_pos, 2000, -r_ang, r_ang );
    h_yphAcc[idet] = new TH2F( Form("hyphAcc_%s",det_name), Form("#phi vs. y, accepted [%s]; y[mm]; #phi[mrad]; counts",det_name), 2000, -r_pos, r_pos, 2000, -r_ang, r_ang );    

    h_mom[idet] = new TH1F( Form("hmom_%s",det_name), Form("momentum [%s]; p [GeV/c]; counts",det_name), 500, -0.10, 0.10 );
    h_momAcc[idet] = new TH1F( Form("hmomAcc_%s",det_name), Form("momentum, accepted [%s]; p [GeV/c]; counts",det_name), 500, -0.10, 0.10 );
    h_mom_x[idet] = new TH1F( Form("hmom_x_%s",det_name), Form("p_{x} [%s]; p_{x} [GeV/c]; counts",det_name), 500, -0.10, 0.10 );
    h_momAcc_x[idet] = new TH1F( Form("hmomAcc_x_%s",det_name), Form("p_{x}, accepted [%s]; p_{x} [GeV/c]; counts",det_name), 500, -0.10, 0.10 );
    h_mom_y[idet] = new TH1F( Form("hmom_y_%s",det_name), Form("p_{y} [%s]; p_{y} [GeV/c]; counts",det_name), 500, -0.10, 0.10 );
    h_momAcc_y[idet] = new TH1F( Form("hmomAcc_y_%s",det_name), Form("p_{y}, accepted [%s]; p_{y} [GeV/c]; counts",det_name), 500, -0.10, 0.10 );
    h_mom_z[idet] = new TH1F( Form("hmom_z_%s",det_name), Form("p_{z} [%s]; p_{z} [GeV/c]; counts",det_name), 500, -0.10, 0.10 );
    h_momAcc_z[idet] = new TH1F( Form("hmomAcc_z_%s",det_name), Form("p_{z}, accepted [%s]; p_{z} [GeV/c]; counts",det_name), 500, -0.10, 0.10 );      
  }

  const int nelt = elements.size();
  TH1F* hAccElmnt = new TH1F("hAcceptanceElement", "hAcceptanceElement", nelt, 0, nelt );
  TH1F* hAccCumul = new TH1F("hAcceptanceAccumulated", "hAcceptanceAccumulated", nelt, 0, nelt );    
  TH2F* hxElement = new TH2F("hxElement","X Enveloppe vs. Element position;; x pos [mm]", nelt, 0, nelt, 200, -r_pos, r_pos);
  TH2F* hyElement = new TH2F("hyElement","Y Enveloppe vs. Element position;; y pos [mm]", nelt, 0, nelt, 200, -r_pos, r_pos);
  TH2F* hxElementTotalAcc = new TH2F("hxElementTotalAcc","hxElementTotalAcc;; x pos [mm]", nelt, 0, nelt, 200, -r_pos, r_pos);
  TH2F* hyElementTotalAcc = new TH2F("hyElementTotalAcc","hyElementTotalAcc;; y pos [mm]", nelt, 0, nelt, 200, -r_pos, r_pos);    
  TH1F* hxDir = new TH1F("hxDir","hxDir; x dir [mrad]", 100, -100, 100);
  TH1F* hyDir = new TH1F("hyDir","hyDir; y dir [mrad]", 100, -100, 100);
    
  for (int ielt=0; ielt<nelt; ++ielt) {
    hAccElmnt->GetXaxis()->SetBinLabel(1+ielt, elementNames[ielt].Data());
    hAccCumul->GetXaxis()->SetBinLabel(1+ielt, elementNames[ielt].Data());
    hxElement->GetXaxis()->SetBinLabel(1+ielt, elementNames[ielt].Data());
    hyElement->GetXaxis()->SetBinLabel(1+ielt, elementNames[ielt].Data());
    hxElementTotalAcc->GetXaxis()->SetBinLabel(1+ielt, elementNames[ielt].Data());
    hyElementTotalAcc->GetXaxis()->SetBinLabel(1+ielt, elementNames[ielt].Data());            
  }
    
  hAccElmnt->GetXaxis()->LabelsOption("v");
  hAccCumul->GetXaxis()->LabelsOption("v");
  hxElement->GetXaxis()->LabelsOption("v");
  hyElement->GetXaxis()->LabelsOption("v");
  hxElementTotalAcc->GetXaxis()->LabelsOption("v");
  hyElementTotalAcc->GetXaxis()->LabelsOption("v");

  Int_t    flag               =  4 ; // if( getVERTEX && writeINDEX == 0)
  Double_t blast              =  0 ; // not available
  Int_t    nParticle          =  1 ;
  if(bWriteDetectors) nParticle = ndet-2; // no beam, no target
  Float_t  event_impact_param = -1.; // not available
  Double_t weight             =  1.; // no gen weights
  Int_t    parentID           = -1 ; // no parent
  Int_t    sourceID           = -1 ; // no source

  FILE* asciiFile = 0;
  asciiFile = fopen(outfile.Data(),"w");

  Int_t ctEvents   = 0;
  Int_t ctTotalTry = 0;
  Int_t maxTry     = 100; // max number of allowed try to prevent endless loop
  Bool_t Accepted  = kTRUE;
  //-----------------------------------------------------------
  for(Int_t ctEvt = 1; ctEvt <= nEvents; ctEvt++)
    {

      if (ctEvt % 1000 == 0) cout << "Event " << ctEvt << endl;

      if(asciiFile) fprintf(asciiFile," %i %i %f %f %i\n",ctEvt,nParticle,blast,event_impact_param,flag);
      ctEvents ++;

      Int_t n             = 0;
      Int_t ctTryParticle = 0;
      while (n < nParticle && ctTryParticle <= maxTry)
	{

	  _acc = 0;
	  vector<TLorentzVector> vPion;
            
	  //-----------------------------------------------------------
	  // create particles
	  Bool_t reDo = kTRUE;
	  Int_t ctTry = 0;
	  while(reDo && ctTry <= maxTry){  // try as long a particle is accepted by the beam line
	    ctTotalTry ++;
	    ctTry++;

	    vector<HBeamParticle>& vhistory = pionbeam.newParticle();
	    if(vhistory[vhistory.size()-1].fAccepted){
	      reDo = kFALSE;
	    }

	    vPion.clear();
	    for(UInt_t i = 0; i < vhistory.size(); i++){
	      TLorentzVector vpion;
	      vpion.SetXYZM(vhistory[i].fP.X(),vhistory[i].fP.Y(),vhistory[i].fP.Z(), 139.56995*0.001);
	      vPion.push_back(vpion);
	    }

	    //-----------------------------------------------------------
	    // qa plots
	    //double the_mrad = TMath::ATan2(vPion[0].Px(),vPion[0].Pz())*1000;
	    //double phi_mrad = TMath::ATan2(vPion[0].Py(),vPion[0].Pz())*1000;

	    //cout << " the_mrad = " << TMath::ATan2(vPion[0].Px(),vPion[0].Pz())*1000 << " Theta()*1000= " << vPion[0].Theta()*1000 << endl;
	    //if (TMath::ATan2(vPion[0].Px(),vPion[0].Pz())!=vPion[0].Phi()) cout << "DISASTER!!!" << endl;
	    
	    hxDir->Fill(TMath::ATan2(vPion[0].Px(),vPion[0].Pz())*1000);
	    hyDir->Fill(TMath::ATan2(vPion[0].Py(),vPion[0].Pz())*1000);

	    for(UInt_t i=0; i< vhistory.size();i++){
	      
	      const double the_mrad = TMath::ATan2(vPion[i].Px(),vPion[i].Pz())*1000;
	      const double phi_mrad = TMath::ATan2(vPion[i].Py(),vPion[i].Pz())*1000;

	      _p[i] = (vPion[i].P() - 1.3)*100./1.3;
	      _x[i] = vhistory[i].fPos.X();
	      _y[i] = vhistory[i].fPos.Y();	      
	      _th[i] = the_mrad;
	      _ph[i] = phi_mrad;

	      for (unsigned int j=0; j<vhistory[i].fX0ms.size(); ++j) {
		_msi_x[j] = vhistory[i].fX0ms[j];
		_msi_th[j] = vhistory[i].fdX0ms[j];
		_msi_y[j] = vhistory[i].fY0ms[j];
		_msi_ph[j] = vhistory[i].fdY0ms[j];
		_msi_dp[j] = vhistory[i].fdP0ms[j];
	      }
	      
	      //double fStateOriginal[5];
	      //double fStateMSdet1[5];
	      //double fStateMSdet2[5];
	      //double fStateMSdiamond[5];
	      //assert(vhistory[i].fStateOriginal[0] == vhistory[i].fX0ms[0]);
	      //assert(vhistory[i].fStateOriginal[1] == vhistory[i].fdX0ms[0]);
	      //assert(vhistory[i].fStateOriginal[2] == vhistory[i].fY0ms[0]);
	      //assert(vhistory[i].fStateOriginal[3] == vhistory[i].fdY0ms[0]);
	      //assert(vhistory[i].fStateOriginal[4] == vhistory[i].fdP0ms[0]);
	      //
	      //assert(vhistory[i].fStateMSdet1[0] == vhistory[i].fX0ms[1]);
	      //assert(vhistory[i].fStateMSdet1[1] == vhistory[i].fdX0ms[1]);
	      //assert(vhistory[i].fStateMSdet1[2] == vhistory[i].fY0ms[1]);
	      //assert(vhistory[i].fStateMSdet1[3] == vhistory[i].fdY0ms[1]);
	      //assert(vhistory[i].fStateMSdet1[4] == vhistory[i].fdP0ms[1]);	      	      	      
	      //
	      //assert(vhistory[i].fStateMSdet2[0] == vhistory[i].fX0ms[2]);
	      //assert(vhistory[i].fStateMSdet2[1] == vhistory[i].fdX0ms[2]);
	      //assert(vhistory[i].fStateMSdet2[2] == vhistory[i].fY0ms[2]);
	      //assert(vhistory[i].fStateMSdet2[3] == vhistory[i].fdY0ms[2]);
	      //assert(vhistory[i].fStateMSdet2[4] == vhistory[i].fdP0ms[2]);	      	      	      
	      //
	      //assert(vhistory[i].fStateMSdiamond[0] == vhistory[i].fX0ms[3]);
	      //assert(vhistory[i].fStateMSdiamond[1] == vhistory[i].fdX0ms[3]);
	      //assert(vhistory[i].fStateMSdiamond[2] == vhistory[i].fY0ms[3]);
	      //assert(vhistory[i].fStateMSdiamond[3] == vhistory[i].fdY0ms[3]);
	      //assert(vhistory[i].fStateMSdiamond[4] == vhistory[i].fdP0ms[3]);	      	      	      
	      
	      //_msi_x[0] = vhistory[i].fStateOriginal[0];
	      //_msi_th[0] = vhistory[i].fStateOriginal[1];
	      //_msi_y[0] = vhistory[i].fStateOriginal[2];
	      //_msi_ph[0] = vhistory[i].fStateOriginal[3];		
	      //_msi_dp[0] = vhistory[i].fStateOriginal[4];
	      //_msi_x[1] = vhistory[i].fStateMSdet1[0];
	      //_msi_th[1] = vhistory[i].fStateMSdet1[1];
	      //_msi_y[1] = vhistory[i].fStateMSdet1[2];
	      //_msi_ph[1] = vhistory[i].fStateMSdet1[3];		
	      //_msi_dp[1] = vhistory[i].fStateMSdet1[4];
	      //_msi_x[2] = vhistory[i].fStateMSdet2[0];
	      //_msi_th[2] = vhistory[i].fStateMSdet2[1];
	      //_msi_y[2] = vhistory[i].fStateMSdet2[2];
	      //_msi_ph[2] = vhistory[i].fStateMSdet2[3];		
	      //_msi_dp[2] = vhistory[i].fStateMSdet2[4];
	      //_msi_x[3] = vhistory[i].fStateMSdiamond[0];
	      //_msi_th[3] = vhistory[i].fStateMSdiamond[1];
	      //_msi_y[3] = vhistory[i].fStateMSdiamond[2];
	      //_msi_ph[3] = vhistory[i].fStateMSdiamond[3];		
	      //_msi_dp[3] = vhistory[i].fStateMSdiamond[4];
	      
	      h_xy[i]->Fill(vhistory[i].fPos.X(),vhistory[i].fPos.Y());
	      h_xth[i]->Fill(vhistory[i].fPos.X(), the_mrad);
	      h_yph[i]->Fill(vhistory[i].fPos.Y(), phi_mrad);
	      h_mom[i]->Fill(vPion   [i].P());
	      h_mom_x[i]->Fill(vPion   [i].Px());
	      h_mom_y[i]->Fill(vPion   [i].Py());
	      h_mom_z[i]->Fill(vPion   [i].Pz());
	      
	    }

	    Accepted = kTRUE;
	    for(UInt_t i = 0 ; i < elements.size(); i++){
	      hxElement->Fill(i,elements[i].fout[0]);
	      hyElement->Fill(i,elements[i].fout[2]);
	      if(!elements[i].fAccepted) Accepted = kFALSE;
	      if(Accepted) hAccCumul->Fill(i);
	    }

	    _acc = Accepted?1:0;
	    tt->Fill();

	    //-----------------------------------------------------------

	  } // end while redo

	  if(ctTry == maxTry){ //
	    ctTryParticle++;
	    cout<<"evt "<<ctEvt<<" no accepted beam particle after "<<ctTry<<" attempts! redo one particle "<<ctTryParticle<<endl;

	    if(ctTryParticle == maxTry)  {
	      cout<<"ERROR : Too many attempts. Outputfile will be corrupted (empty or to small event)"<<endl;
	      if(asciiFile) fclose(asciiFile);

	      return 1;
	    }

	    continue;
	  }

	  if(vhistory.size() < 3) {
	    cout<<"no history available!"<<endl;
	    continue;
	  }

	  n++; // succesfull
            
	  //-----------------------------------------------------------
	  //-----------------------------------------------------------
	  // new particle
	  if(asciiFile )
	    {
	      //target first
	      UInt_t itarget = indexOut ;
	      fprintf(asciiFile," %e %e %e %e %e %e %e %e %i %i %i %e\n",                 // 12 vars
		      vPion[itarget].E(),vPion[itarget].Px(),vPion[itarget].Py(),vPion[itarget].Pz(),
		      0.       ,vhistory[itarget].fPos.X(),vhistory[itarget].fPos.Y(),vhistory[itarget].fPos.Z(),
		      vhistory[itarget].fPid , sourceID , parentID, weight);
	      if(bWriteDetectors){

		UInt_t ndet = sizeof(indexDet)/sizeof(Int_t);
		for(UInt_t j = 0; j < ndet; j ++){   // write out wanted beam detector hits
		  Int_t i = j;
		  fprintf(asciiFile," %e %e %e %e %e %e %e %e %i %i %i %e\n",                 // 12 vars
			  vPion[i].E(),vPion[i].Px(),vPion[i].Py(),vPion[i].Pz(),
			  0.       ,vhistory[i].fPos.X(),vhistory[i].fPos.Y(),vhistory[i].fPos.Z(),
			  vhistory[i].fPid , sourceID , parentID, weight);
		}
	      }
	    }
	  //-----------------------------------------------------------

	  //-----------------------------------------------------------
	  // qa plots
	  if(Accepted){
	    for(UInt_t i=0; i< vhistory.size();i++){

	      const double the_mrad = TMath::ATan2(vPion[i].Px(),vPion[i].Pz())*1000;
	      const double phi_mrad = TMath::ATan2(vPion[i].Py(),vPion[i].Pz())*1000;

	      h_xyAcc[i]->Fill(vhistory[i].fPos.X(),vhistory[i].fPos.Y());
	      h_xthAcc[i]->Fill(vhistory[i].fPos.X(), the_mrad);
	      h_yphAcc[i]->Fill(vhistory[i].fPos.Y(), phi_mrad);	      
	      h_momAcc[i]->Fill(vPion   [i].P());
	      h_momAcc_x[i]->Fill(vPion   [i].Px());
	      h_momAcc_y[i]->Fill(vPion   [i].Py());
	      h_momAcc_z[i]->Fill(vPion   [i].Pz());
	    }
	    for(UInt_t i = 0 ; i < elements.size(); i++){
	      hxElementTotalAcc->Fill(i,elements[i].fout[0]);
	      hyElementTotalAcc->Fill(i,elements[i].fout[2]);
	    }
	  }
	  //-----------------------------------------------------------

	} // end particle loop

    } // end event loop
  //-----------------------------------------------------------

  for(UInt_t i = 0 ; i < elements.size(); i++){
    hAccElmnt->SetBinContent(i+1,elements[i].fCtAll > 0 ? 100 - (elements[i].fCtFail/(Double_t)elements[i].fCtAll)*100 : 100);
  }
  hAccCumul->Scale(1./(elements[0].fCtAll/100.));

  if(asciiFile) fclose(asciiFile);

  pionbeam.printBeamLine(kFALSE);   // print acceptance statistic for detecors and elements
  pionbeam.printDetectors();
    
  for (UInt_t idet=0; idet< ndet; ++idet) {
    fout->cd("xy");
    h_xy[idet]->Write();
    h_xyAcc[idet]->Write();
    fout->cd("xth");
    h_xth[idet]->Write();
    h_xthAcc[idet]->Write();    
    fout->cd("yph");
    h_yph[idet]->Write();    
    h_yphAcc[idet]->Write();
    fout->cd("mom");
    h_mom[idet]->Write();
    h_momAcc[idet]->Write();
    fout->cd("mom_x");      
    h_mom_x[idet]->Write();
    h_momAcc_x[idet]->Write();
    fout->cd("mom_y");
    h_mom_y[idet]->Write();
    h_momAcc_y[idet]->Write();
    fout->cd("mom_z");
    h_mom_z[idet]->Write();
    h_momAcc_z[idet]->Write();
  }

  fout->cd("acceptance");
  hAccElmnt->Write();
  hAccCumul->Write();
  hxElement->Write();
  hyElement->Write();
  hxElementTotalAcc->Write();
  hyElementTotalAcc->Write();
  fout->cd("dir");
  hxDir->Write();
  hyDir->Write();

  fout->cd();
  tt->Write();
  
  fout->Close();
    
  cout<<"Total Acceptance : "<< (ctTotalTry > 0 ?  (ctEvents/(Double_t)ctTotalTry)*100 : 100)<<" %"<<endl;

  return 0;
}
